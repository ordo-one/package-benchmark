//
// Copyright (c) 2023 Ordo One AB.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//

import SystemPackage

#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unsupported Platform")
#endif

extension BenchmarkTool {
    var benchmarksDirectory: String { "Benchmarks" }

    mutating func appendBenchmarkTargetToPackageSwift() {
        guard let targetName else {
            failBenchmark("targetName not specified for appendBenchmarkTargetToPackageSwift()")
            return
        }

        var boilerplate = """

            // Benchmark of \(targetName)
            package.targets += [
                .executableTarget(
                    name: "\(targetName)",
                    dependencies: [
                        .product(name: "Benchmark", package: "package-benchmark"),
                    ],
                    path: "Benchmarks/\(targetName)",
                    plugins: [
                        .plugin(name: "BenchmarkPlugin", package: "package-benchmark")
                    ]
                ),
            ]
            """

        var outputPath = FilePath(baselineStoragePath) // package
        var subPath = FilePath() // subpath rooted in package used for directory creation
        subPath.append("Package.swift") // package/Benchmarks/targetName
        outputPath.append(subPath.components)

        print("Adding new executable target \(targetName) to \(outputPath.description)")

        // Write out benchmark boilerplate
        do {
            let fd = try FileDescriptor.open(
                outputPath,
                .writeOnly,
                options: [.append],
                permissions: .ownerReadWrite
            )

            do {
                try fd.closeAfter {
                    do {
                        try boilerplate.withUTF8 {
                            _ = try fd.write(UnsafeRawBufferPointer($0))
                        }
                    } catch {
                        print("Failed to write to file \(outputPath)")
                    }
                }
            } catch {
                print("Failed to close fd for \(outputPath) after write.")
            }

        } catch {
            if errno == EPERM {
                print("Lacking permissions to write to \(outputPath)")
                print("Give benchmark plugin permissions by running with e.g.:")
                print("")
                print("swift package --allow-writing-to-package-directory benchmark init \(targetName)")
                print("")
            } else {
                print("Failed to open file \(outputPath), errno = [\(errno)]")
            }
        }
    }

    mutating func createBenchmarkTarget() {
        guard let targetName else {
            failBenchmark("targetName not specified for createBenchmarkTarget()")
            return
        }

        var boilerplate = """
            // Benchmark boilerplate generated by Benchmark

            import Benchmark
            import Foundation

            let benchmarks = {
                Benchmark("SomeBenchmark") { benchmark in
                    for _ in benchmark.scaledIterations {
                        blackHole(Date()) // replace this line with your own benchmark
                    }
                }
                // Add additional benchmarks here
            }

            """

        var outputPath = FilePath(baselineStoragePath) // package
        var subPath = FilePath() // subpath rooted in package used for directory creation

        subPath.append(benchmarksDirectory) // package/Benchmarks
        subPath.append("\(targetName)") // package/Benchmarks/targetName

        outputPath.createSubPath(subPath) // Create destination subpath if needed
        outputPath.append(subPath.components)
        outputPath.append("\(targetName).swift")

        print("Creating benchmark in \(outputPath.description)")

        // Write out benchmark boilerplate, open with .exclusiveCreate to abort if file exists
        do {
            let fd = try FileDescriptor.open(
                outputPath,
                .writeOnly,
                options: [.create, .exclusiveCreate],
                permissions: .ownerReadWrite
            )

            do {
                try fd.closeAfter {
                    do {
                        try boilerplate.withUTF8 {
                            _ = try fd.write(UnsafeRawBufferPointer($0))
                        }
                    } catch {
                        print("Failed to write to file \(outputPath)")
                        return
                    }
                }
            } catch {
                print("Failed to close fd for \(outputPath) after write.")
            }

        } catch {
            switch errno {
            case EPERM:
                print("Lacking permissions to write to \(outputPath)")
                print("Give benchmark plugin permissions by running with e.g.:")
                print("")
                print("swift package --allow-writing-to-package-directory benchmark init \(targetName)")
                print("")
            case EEXIST:
                print("File already exists at \(outputPath), aborting benchmark target generation.")
                print("Consider reverting repository state and add benchmark target manually instead.")
            default:
                print("Failed to open file \(outputPath), errno = [\(errno)]")
            }
            return
        }

        appendBenchmarkTargetToPackageSwift()
    }
}
