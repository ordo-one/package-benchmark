//
// Copyright (c) 2023 Ordo One AB.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//

import SystemPackage

#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
import Glibc
#else
#error("Unsupported Platform")
#endif

extension BenchmarkTool {
    var benchmarksDirectory: String { "Benchmarks" }

    mutating func appendBenchmarkTargetToPackageSwift() {
        guard let targetName else {
            failBenchmark("targetName not specified for appendBenchmarkTargetToPackageSwift()")
            return
        }

        var boilerplate = """

        // Benchmark of \(targetName)
        package.targets += [
            .executableTarget(
                name: "\(targetName)",
                dependencies: [
                    .product(name: "Benchmark", package: "package-benchmark"),
                    .product(name: "BenchmarkPlugin", package: "package-benchmark")
                ],
                path: "Benchmarks/\(targetName)"
            ),
        ]
        """

        var outputPath = FilePath(baselineStoragePath) // package
        var subPath = FilePath() // subpath rooted in package used for directory creation
        subPath.append("Package.swift") // package/Benchmarks/targetName
        outputPath.append(subPath.components)

        // Write out benchmark boilerplate
        do {
            let fd = try FileDescriptor.open(
                outputPath, .writeOnly, options: [.append], permissions: .ownerReadWrite
            )

            do {
                try fd.closeAfter {
                    do {
                        try boilerplate.withUTF8 {
                            _ = try fd.write(UnsafeRawBufferPointer($0))
                        }
                    } catch {
                        print("Failed to write to file \(outputPath)")
                    }
                }
            } catch {
                print("Failed to close fd for \(outputPath) after write.")
            }

        } catch {
            if errno == EPERM {
                print("Lacking permissions to write to \(outputPath)")
                print("Give benchmark plugin permissions by running with e.g.:")
                print("")
                print("swift package --allow-writing-to-package-directory benchmark init \(targetName)")
                print("")
            } else {
                print("Failed to open file \(outputPath), errno = [\(errno)]")
            }
        }
    }

    mutating func createBenchmarkTarget() {
        guard let targetName else {
            failBenchmark("targetName not specified for createBenchmarkTarget()")
            return
        }

        print("Creating benchmark \(targetName) in \(self.baselineStoragePath)")

        var boilerplate = """
        // Benchmark boilerplate generated by Benchmark

        import Benchmark
        import Foundation

        let benchmarks = {
            Benchmark("SomeBenchmark") { benchmark in
                for _ in benchmark.scaledIterations {
                    blackHole(Date()) // replace this line with your own benchmark
                }
            }
            // Add additional benchmarks here
        }

        """

        var outputPath = FilePath(baselineStoragePath) // package
        var subPath = FilePath() // subpath rooted in package used for directory creation

        subPath.append(benchmarksDirectory) // package/Benchmarks
        subPath.append("\(targetName)") // package/Benchmarks/targetName

        outputPath.createSubPath(subPath) // Create destination subpath if needed
        outputPath.append(subPath.components)
        outputPath.append("\(targetName).swift")

        // Write out benchmark boilerplate, open with .exclusiveCreate to abort if file exists
        do {
            let fd = try FileDescriptor.open(
                outputPath, .writeOnly, options: [.create, .exclusiveCreate], permissions: .ownerReadWrite
            )

            do {
                try fd.closeAfter {
                    do {
                        try boilerplate.withUTF8 {
                            _ = try fd.write(UnsafeRawBufferPointer($0))
                        }
                    } catch {
                        print("Failed to write to file \(outputPath)")
                        return
                    }
                }
            } catch {
                print("Failed to close fd for \(outputPath) after write.")
            }

        } catch {
            switch errno {
            case EPERM:
                print("Lacking permissions to write to \(outputPath)")
                print("Give benchmark plugin permissions by running with e.g.:")
                print("")
                print("swift package --allow-writing-to-package-directory benchmark init \(targetName)")
                print("")
            case EEXIST:
                print("File already exists at \(outputPath), aborting benchmark target generation.")
                print("Consider reverting repository state and add benchmark target manually instead.")
            default:
                print("Failed to open file \(outputPath), errno = [\(errno)]")
            }
            return
        }

        appendBenchmarkTargetToPackageSwift()
    }
}
